<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://172.17.73.80:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://172.17.73.80:4000/" rel="alternate" type="text/html" /><updated>2019-11-22T18:43:40+08:00</updated><id>http://172.17.73.80:4000/feed.xml</id><title type="html">Gavin Blog</title><subtitle>关于软件测试, 与你一起发现更大的世界</subtitle><entry><title type="html">nose测试用例编写规则基本要求</title><link href="http://172.17.73.80:4000/2019/11/21/write-nose-test-case-role/" rel="alternate" type="text/html" title="nose测试用例编写规则基本要求" /><published>2019-11-21T00:00:00+08:00</published><updated>2019-11-21T00:00:00+08:00</updated><id>http://172.17.73.80:4000/2019/11/21/write-nose-test-case-role</id><content type="html" xml:base="http://172.17.73.80:4000/2019/11/21/write-nose-test-case-role/">&lt;h2 id=&quot;用例编写基本规则要求&quot;&gt;&lt;strong&gt;用例编写基本规则要求&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;1test_xxxxpy尽量避免逻辑操作纯粹是function的调用&quot;&gt;1、test_xxxx.py尽量避免逻辑操作，纯粹是function的调用&lt;/h3&gt;

&lt;h3 id=&quot;2测试用例的名称携带上testlink对应测试用例的编号&quot;&gt;2、测试用例的名称，携带上TestLink对应测试用例的编号&lt;/h3&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;shadow&quot; src=&quot;/img/in-post/test_link_case_no.png&quot; width=&quot;1200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;test_9143_same_daemon_different_signal， 对应TestLink的用例为：&lt;/p&gt;

&lt;p&gt;Sc-9143:Same daemon, different signal core file)&lt;/p&gt;

&lt;h3 id=&quot;3测试用例的__doc__不得含有中文字符&quot;&gt;3、测试用例的__doc__，不得含有中文字符&lt;/h3&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;​    “”” Sc-9143:Same daemon，different signal core file “””&lt;/p&gt;

&lt;p&gt;这里的逗号，是中文符号，会导致用例报错：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;shadow&quot; src=&quot;/img/in-post/doc_error.png&quot; width=&quot;1200&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4避免测试用例之间存在依赖关系&quot;&gt;4、避免测试用例之间存在依赖关系&lt;/h3&gt;

&lt;p&gt;（1）每个测试suite中的测试用例互相不依赖；&lt;/p&gt;

&lt;p&gt;（2）测试suite中的用例，尽可能避免依赖关系&lt;/p&gt;

&lt;p&gt;如TestLink中上一个用例是创建，下一个用例是删除，则合并这两个用例为一个自动化测试用例。&lt;/p&gt;

&lt;h3 id=&quot;5日志记录对齐要求&quot;&gt;5、日志记录对齐要求&lt;/h3&gt;

&lt;p&gt;日志记录，执行动作的记录，开头增加[Action]；检查动作的记录，开头增加[Check];&lt;/p&gt;

&lt;p&gt;断言记录的log，开头增加[ERROR]； 操作成功的log，开头增加[SUCCESS]； 不需要检查点的，开头增加[Skip]；&lt;/p&gt;

&lt;p&gt;具体要求如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[Prepare]&lt;/strong&gt; &lt;strong&gt;后面跟2&lt;/strong&gt;&lt;strong&gt;个空格；&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[Action]&lt;/strong&gt; &lt;strong&gt;后面跟3&lt;/strong&gt;&lt;strong&gt;个空格&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[Start]&lt;/strong&gt; &lt;strong&gt;后面跟4&lt;/strong&gt;&lt;strong&gt;个空格&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[Check]&lt;/strong&gt; &lt;strong&gt;后面跟4&lt;/strong&gt;&lt;strong&gt;个空格&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[Success]&lt;/strong&gt; &lt;strong&gt;后面跟2&lt;/strong&gt;&lt;strong&gt;个空格&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[Skip]&lt;/strong&gt; &lt;strong&gt;后面跟5&lt;/strong&gt;&lt;strong&gt;个空格&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;debug&lt;/strong&gt;&lt;strong&gt;级别的log&lt;/strong&gt;&lt;strong&gt;，内容前面跟2&lt;/strong&gt;&lt;strong&gt;个-&lt;/strong&gt;&lt;strong&gt;，之后&lt;/strong&gt; &lt;strong&gt;再加2&lt;/strong&gt;&lt;strong&gt;个空格&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;assert&lt;/strong&gt;&lt;strong&gt;中，[ERROR]&lt;/strong&gt; &lt;strong&gt;后面跟2&lt;/strong&gt;&lt;strong&gt;个空格&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;6用例的执行顺序&quot;&gt;6、用例的执行顺序&lt;/h3&gt;

&lt;p&gt;执行 nosetests -s 可看到调用顺序，用例执行顺序，根据ASSII进行排序，在用例有关联情况下，需要对用例名称增加数字编号，人为的干预用例执行顺序，比如test_1_xxx, test_2_yyy。&lt;/p&gt;

&lt;h3 id=&quot;7代码规范要求&quot;&gt;7、代码规范要求&lt;/h3&gt;

&lt;p&gt;执行pylint，确保检查结果分值=10&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;pylint -r y testcasebase/Virtual_Storage/vs_user.py --rcfile=./pylintrc
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;MESSAGE_TYPE 有如下几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(C) 惯例。违反了编码风格标准&lt;/li&gt;
  &lt;li&gt;(R) 重构。写得非常糟糕的代码。&lt;/li&gt;
  &lt;li&gt;(W) 警告。某些 Python 特定的问题。&lt;/li&gt;
  &lt;li&gt;(E) 错误。很可能是代码中的错误。&lt;/li&gt;
  &lt;li&gt;(F) 致命错误。阻止 Pylint 进一步运行的错误&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8用例文件权限&quot;&gt;8、用例文件权限&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;统一使用644&lt;/strong&gt;&lt;strong&gt;权限&lt;/strong&gt;，否则默认情况下无法被nosetests search到，自然就不会被执行到，因为nosetesst默认只查找644权限的文件。&lt;/p&gt;

&lt;h3 id=&quot;9避免在class与setup_class之间做比较重的动作&quot;&gt;9、避免在class与setup_class之间做比较重的动作&lt;/h3&gt;

&lt;p&gt;比如下文中的RRS用例 test_remote_replication_tasks.py（下文代码是一个不可取的代码，这里仅做示例用）&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;shadow&quot; src=&quot;/img/in-post/bad_eg.png&quot; width=&quot;1200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在class TestReplicationTask 与setup_class之间，启用了RRS服务、创建了S3账号并创建bucket，最后上传了一些object到bucket中。正常情况下，这部分动作应该是在用例被执行之前要做的，然后会立刻执行setup_class中的动作，接着执行用例，最后teardown。实际上，在run.py 去执行所有测试用例的时候， 在init完所有的class之后（即创建完session后），会先执行所有test_xx.py中定义在class 与 setup_class之间的所有动作， 这也无可厚非，但是，由于约束了用例的执行顺序，case_2_Accounts 会优先于 case_5_Remote_DR被执行，而case_2_Accounts里将其他pool设置为S3 pool的动作，这势必会清理掉在执行run.py init结束后所创建的所有bucket与bucket下的object，到case_5_Remote_DR被执行时，曾经创建的bucket与bucket下的object早已不复存在，自然case_5_Remote_DR下面的相关用例就会失败。&lt;/p&gt;

&lt;p&gt;故而，建议：&lt;/p&gt;

&lt;p&gt;避免在class与setup_class之间做比较重的动作。对于较重的动作，放在setup_class中，好处有2：&lt;/p&gt;

&lt;p&gt;（1）避免被其他class import时做更多、更重的动作&lt;/p&gt;

&lt;p&gt;（2）避免用例suite间前后有依赖关系，给用例排查带来难度&lt;/p&gt;

&lt;h3 id=&quot;10用例文件名称用例中定义变量名称全局唯一&quot;&gt;10、用例文件名称、用例中定义变量名称全局唯一&lt;/h3&gt;

&lt;p&gt;对于测试用例中定义的变量，诸如文件夹名称、子目录名称、名称、名称、名称、名称、用例执行过程中产生的文件的名称等等，要保持全局唯一，即所有用例中不出现同名的文件名、目录名、名等。当有用例出错时，可以根据这个名称，定位到是哪个用例产生了问题，因为具有唯一性，可以排除其他用例带来的干扰。&lt;/p&gt;</content><author><name>Gavin</name></author><category term="Automation" /><category term="nose" /><summary type="html">用例编写基本规则要求</summary></entry><entry><title type="html">nose进度条中展示执行用例数与总数</title><link href="http://172.17.73.80:4000/2019/11/20/nose-progress-bar/" rel="alternate" type="text/html" title="nose进度条中展示执行用例数与总数" /><published>2019-11-20T00:00:00+08:00</published><updated>2019-11-20T00:00:00+08:00</updated><id>http://172.17.73.80:4000/2019/11/20/nose-progress-bar</id><content type="html" xml:base="http://172.17.73.80:4000/2019/11/20/nose-progress-bar/">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;在使用nose 插件时，发现这个插件只能显示进度（nose-progressive），并不知道当前执行多少个用例，执行到哪个了，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;shadow&quot; src=&quot;/img/in-post/before_progress_bar.png&quot; width=&quot;1200&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;期待效果&quot;&gt;期待效果&lt;/h1&gt;

&lt;p&gt;这里源码有个问题，同时使用高亮（nose的  colorama  和  walkingnine-colorunit）和进度，会导致高亮和进度在用例执行结果信息输出时，两部分信息展示混杂在一起，已经修改源码解决，安装后无需做任何调整。&lt;/p&gt;

&lt;p&gt;由于只能看到一个进度条，无法知道当前要执行多少个用例，以及执行到了第几个用例，再次修改之。在进度条前面，显示已执行用例数（包含当前正在执行的用例）与总共要执行的用例数，效果如下图所示：&lt;/p&gt;

&lt;p&gt;于是对源码（nose-progressive-master/noseprogressive/bar.py）做了如下调整：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;def update(self, test_path, number):
    &quot;&quot;&quot;Draw an updated progress bar.

    At the moment, the graph takes a fixed width, and the test identifier
    takes the rest of the row, truncated from the left to fit.

    test_path -- the selector of the test being run
    number -- how many tests have been run so far, including this one

    &quot;&quot;&quot;
    # TODO: Play nicely with absurdly narrow terminals. (OS X's won't even
    # go small enough to hurt us.)

    # Figure out graph:
    GRAPH_WIDTH = 14
    # min() is in case we somehow get the total test count wrong. It's tricky.
    num_filled = int(round(min(1.0, float(number) / self.max) * GRAPH_WIDTH))
    graph = ''.join([self._fill_cap(' ' * num_filled),
                     self._empty_cap(self._empty_char * (GRAPH_WIDTH - num_filled))])

    # Figure out the test identifier portion:
    # Avoid causing progress bar wraps due to more test cases when 
    # show number of runned/total test cases, modify it by wangyunzeng 2019-01-30
    # cols_for_path = self.cols - GRAPH_WIDTH - 2  # 2 spaces between path &amp;amp; graph
    cols_for_path = self.cols - GRAPH_WIDTH - 13  # 13 spaces between path &amp;amp; graph
    if len(test_path) &amp;gt; cols_for_path:
        test_path = test_path[len(test_path) - cols_for_path:]
    else:
        test_path += ' ' * (cols_for_path - len(test_path))

    # Put them together, and let simmer:
    # Show number of runned/total test cases, modify it by wangyunzeng 2019-01-30
    # self.last = self._term.bold(test_path) + '  ' + graph
    self.last = self._term.bold(test_path) + '  ' + str(number) + '/' + str(self.max) + '  ' + graph
    with self._at_last_line():
        self.stream.write(self.last)
    self.stream.flush()
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再次执行，效果图如下：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;shadow&quot; src=&quot;/img/in-post/after_progress_bar.png&quot; width=&quot;1200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;是不是清爽很多了~&lt;/p&gt;</content><author><name>Gavin</name></author><category term="Nose" /><category term="Automation" /><category term="Progress bar" /><summary type="html">概述</summary></entry></feed>