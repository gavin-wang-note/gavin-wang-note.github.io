<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2023-07-30T21:34:39+08:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Gavin Blog</title><subtitle>关于软件测试, 与你一起发现更大的世界</subtitle><entry><title type="html">修复memcache 未授权访问漏洞</title><link href="http://0.0.0.0:4000/2023/07/30/memcache_port_limit/" rel="alternate" type="text/html" title="修复memcache 未授权访问漏洞" /><published>2023-07-30T00:00:00+08:00</published><updated>2023-07-30T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2023/07/30/memcache_port_limit</id><content type="html" xml:base="http://0.0.0.0:4000/2023/07/30/memcache_port_limit/"># 背景说明 

memcache 未授权访问漏洞修复，修复方法是通过系统的防火墙来禁止其他ip访问


# patch步骤 

## 1. 检查 

客户端确认端口访问情况，可以看到 11211 可以访问


```
root@wyz-node2:~# telnet 10.10.10.134 11211
Trying 10.10.10.134...
Connected to 10.10.10.134.
Escape character is '^]'.
dd^H^H^H^H^C^C^C^C^C^C^C^C
```

## 2. 存储节点增加iptable（每个节点都要做）

注意其中ip 需要根据实际情况替换
 
```
iptables -I INPUT -p tcp --dport 11211 -j DROP
iptables -I INPUT -s 127.0.0.1 -p tcp --dport 11211 -j ACCEPT
iptables -I INPUT -s 172.17.73.134 -p tcp --dport 11211 -j ACCEPT
iptables -I INPUT -s 172.17.73.135 -p tcp --dport 11211 -j ACCEPT
iptables -I INPUT -s 172.17.73.136 -p tcp --dport 11211 -j ACCEPT
iptables -I INPUT -s 10.10.10.134 -p tcp --dport 11211 -j ACCEPT
iptables -I INPUT -s 10.10.10.135 -p tcp --dport 11211 -j ACCEPT
iptables -I INPUT -s 10.10.10.136 -p tcp --dport 11211 -j ACCEPT
root@wyz:~/docker-file/first# telnet 172.17.73.134 11211
```

## 3. 效果验证 

每个节点做完后，通过 客户端 telnet 11211端口，验证是否可以访问。可以看到已经无法访问了

```
root@wyz:~/docker-file/first# telnet 172.17.73.134 11211

Trying 172.17.73.134...
```</content><author><name>Gavin</name></author><category term="memchche" /><category term="securite" /><category term="Linux" /><summary type="html">背景说明</summary></entry><entry><title type="html">pyserial 使用指导</title><link href="http://0.0.0.0:4000/2023/07/26/pyserial_use_guide/" rel="alternate" type="text/html" title="pyserial 使用指导" /><published>2023-07-26T00:00:00+08:00</published><updated>2023-07-26T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2023/07/26/pyserial_use_guide</id><content type="html" xml:base="http://0.0.0.0:4000/2023/07/26/pyserial_use_guide/"># 概述


利用pyserial，可以访问串口，发送串口命令，当然，根据串口返回结果，判断命令执行正确性。

本文简介pyserial一些常用函数的使用方法与场景，并做一些阐述。





# 实践


## 初始化(连接串口)


### 串口连接示例



```
&gt;&gt;&gt; import serial
&gt;&gt;&gt; ser = serial.Serial('COM7', 115200, timeout=1)
```



不同平台连接不同类型串口，示例如下：

```
ser = serial.Serial(&quot;/dev/ttyUSB0&quot;, 9600, timeout=0.5) # 使用USB连接串行口
ser = serial.Serial(&quot;/dev/ttyAMA0&quot;, 9600, timeout=0.5) # 使用树莓派的GPIO口连接串行口
ser = serial.Serial(&quot;com1&quot;, 9600, timeout=0.5)# winsows系统使用com1口连接串行口
ser = serial.Serial(&quot;/dev/ttyS1&quot;, 9600, timeout=0.5)# Linux系统使用com1口连接串行口
```



连接串口时，除了主要的几个参数显示携带外，其他参数可以使用默认值，当然，可以携带全部参数，示例如下：



当然， 可以在连接串口时，携带上全部参数：



```
ser = serial.Serial(
port=None,              # number of device, numbering starts at
# zero. if everything fails, the user
# can specify a device string, note
# that this isn't portable anymore
# if no port is specified an unconfigured
# an closed serial port object is created
baudrate=9600,          # baud rate
bytesize=EIGHTBITS,     # number of databits
parity=PARITY_NONE,     # enable parity checking
stopbits=STOPBITS_ONE,  # number of stopbits
timeout=None,           # set a timeout value, None for waiting forever
xonxoff=0,              # enable software flow control
rtscts=0,               # enable RTS/CTS flow control
interCharTimeout=None   # Inter-character timeout, None to disable
)
```





### **对象属性**

- name —— 设备名字
- port —— 读或者写端口，比如示例中的'COM7'，这里只接受字符串类型内容
- baudrate —— 波特率，比如示例中的115200，波特率端口，默认9600
- bytesize —— 字节大小
- parity —— 校验位
- stopbits —— 停止位，取值(1,2)
- timeout —— 读超时设置
- writeTimeout —— 写超时
- xonxoff —— 软件流控
- rtscts —— 硬件流控
- dsrdtr —— 硬件流控
- interCharTimeout —— 字符间隔超时



### 属性介绍



说明：

​    如未显示携带，pyserial设有默认值。



**name**

```
&gt;&gt;&gt; print ser.name
COM7

```



**port**

```
&gt;&gt;&gt; print ser.port
COM7
&gt;&gt;&gt; print ser.portstr
COM7
&gt;&gt;&gt;
```



**baudrate**

```
&gt;&gt;&gt; print ser.baudrate
115200
&gt;&gt;&gt;
```



**bytesize**

```
&gt;&gt;&gt; print ser.bytesize
8
```



**parity**

```
&gt;&gt;&gt; print ser.parity
N
```



**stopbits**

```
&gt;&gt;&gt; print ser.stopbits
1
```



**timeout**

```
&gt;&gt;&gt; print ser.timeout
None
```



关于timeout：

```
timeout=None            # wait forever
timeout=0               # non-blocking mode (return immediately on read)
timeout=x               # set timeout to x seconds (float allowed)
```





**writeTimeout**

```
&gt;&gt;&gt; print ser.writeTimeout
None
```



**xonxoff**

```
&gt;&gt;&gt; print ser.xonxoff
False
```



**rtscts**

```
&gt;&gt;&gt; print ser.rtscts
False
```



**dsrdtr**

```
&gt;&gt;&gt; print ser.dsrdtr
False
```



**interCharTimeout**

```
&gt;&gt;&gt; print ser.interCharTimeout
None
&gt;&gt;&gt;
```





**一个命令获取当前串口属性信息**：



```
&gt;&gt;&gt; ser.getSettingsDict
&lt;bound method Serial.getSettingsDict of Serial&lt;id=0x2cc3358, open=True&gt;(port='com7', baudrate=115200, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, dsrdtr=False)&gt;
&gt;&gt;&gt;
```







## 查看pyserial 属性信息



```
&gt;&gt;&gt; import serial
&gt;&gt;&gt; ser = serial.Serial('COM7', 115200)
&gt;&gt;&gt; dir(ser)
['BAUDRATES', 'BYTESIZES', 'PARITIES', 'STOPBITS', '_GetCommModemStatus', '_SAVED_SETTINGS', '__abstractmethods__', '__class__', '__delattr__', '__doc__', '__enter__', '__exit__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', '__metaclass__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '_abc_cache', '_abc_negative_cache', '_abc_negative_cache_version', '_abc_registry', '_cancel_overlapped_io', '_checkClosed', '_checkReadable', '_checkSeekable', '_checkWritable', '_close', '_reconfigure_port', '_update_break_state', '_update_dtr_state', '_update_rts_state', 'applySettingsDict', 'apply_settings', 'baudrate', 'break_condition', 'bytesize', 'cancel_read', 'cancel_write', 'cd', 'close', 'closed', 'cts', 'dsr', 'dsrdtr', 'dtr', 'exclusive', 'fileno', 'flush', 'flushInput', 'flushOutput', 'getCD', 'getCTS', 'getDSR', 'getRI', 'getSettingsDict', 'get_settings', 'inWaiting', 'in_waiting', 'interCharTimeout', 'inter_byte_timeout', 'iread_until', 'isOpen', 'isatty', 'next', 'open', 'out_waiting', 'parity', 'port', 'read', 'read_all', 'read_until', 'readable', 'readall', 'readinto', 'readline', 'readlines', 'reset_input_buffer', 'reset_output_buffer', 'ri', 'rs485_mode', 'rts', 'rtscts', 'seek', 'seekable', 'sendBreak', 'send_break', 'setDTR', 'setPort', 'setRTS', 'set_buffer_size', 'set_output_flow_control', 'stopbits', 'tell', 'timeout', 'truncate', 'writable', 'write', 'writeTimeout', 'write_timeout', 'writelines', 'xonxoff']
&gt;&gt;&gt;
```





**对象常用方法**

- ser.isOpen() —— 查看端口是否被打开
- ser.open() —— 打开端口
- ser.close() —— 关闭端口
- ser.read() —— 从端口读字节数据。默认1个字节
- ser.read_all() —— 从端口接收全部数据，默认4096字节
- ser.write(&quot;s&quot;) —— 向端口写数据 &quot;s&quot;
- ser.readline() —— 读一行数据
- ser.readlines() —— 读多行数据
- in_waiting —— 返回接收缓存中的字节数，方法同inWaiting()
- flush() —— 等待所有数据写出
- flushInput() —— 丢弃接收缓存中的所有数据
- flushOutput() —— 终止当前写操作，并丢弃发送缓存中的数据
- read_until(&quot;s&quot;) —— 读取串口数据，知道出现预期字符串&quot;s&quot;就终止读取
- set_buffer_size(rx_size=value1, tx_size=value2) —— 设置buffer 大小，默认4096bytes，上限2147483647
- sendBreak()   —— send break condition
- setRTS(level=1)  —— set RTS line to specified logic level
- setDTR(level=1) —— set DTR line to specified logic level
- getCTS()  —— return the state of the CTS line
- getDSR()  —— return the state of the DSR line
- getRI()  —— return the state of the RI line
- getCD() —— return the state of the CD line










# 常用代码示例



说明：

​      如下示例，借助虚拟串口软件（Virtual Serial Port Driver Pro）创建了两个虚拟串口（COM7 和 COM8），并将两个串口短接（即COM7与COM8互通，形成回环）



### 获取当前设备上所有串口信息



```
    @staticmethod
    def list_serial_ports():
        &quot;&quot;&quot;
        Lists serial port names
        :raises EnvironmentError:   On unsupported or unknown platforms
        :returns: A list of the serial ports available on the system
        &quot;&quot;&quot;
        if sys.platform.startswith('win'):
            ports = ['COM%s' % (i + 1) for i in range(256)]
        elif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'):
            # this excludes your current terminal &quot;/dev/tty&quot;
            ports = glob.glob('/dev/tty[A-Za-z]*')
        elif sys.platform.startswith('darwin'):
            ports = glob.glob('/dev/tty.*')
        else:
            raise EnvironmentError('Unsupported platform')
    
        result = []
        for port in ports:
            try:
                s = serial.Serial(port)
                s.close()
                result.append(port)
            except (OSError, serial.SerialException):
                pass
    
        return result
```





### 字符串的发送接收



```
import serial
ser = serial.Serial('COM7', 115200)
writen = ser.write('Hello, i send a string command to serial')
print writen
recevied = ser.read(writen )
print recevied
```



其中，read(value)方法的参数value为需要读取的字符长度：

* 如果指定了value的值，当且仅当串口 buffer内容长度小于value值时，read动作会一直等待，直到串口buffer &gt;= value时，read结束。比如read(10)，而buffer内容长度超过10字节，则只读取前面10个字节内容。
* 如果想要全部读取，提供两个方法：

​     （1）inWaiting() 或者 in_waiting：监测接收字符。 inWaitting返回接收字符串的长度值，然后把这个值赋给read做参数。

​     （2）read_all() ：读取全部字符



说明:

​    inWaiting()或者in_wating，使用如下：

```
&gt;&gt;&gt; ser.inWaiting()
36L
&gt;&gt;&gt; ser.in_waiting
36L
&gt;&gt;&gt;
```

如果有非零值，说明串口buffer中有内容可读。



​    read_all() 使用如下:

```
&gt;&gt;&gt; ser.read_all()
'I received what you send, thanks.'
&gt;&gt;&gt;
```



还有另外一个方法readall()，但是没有理解掉这个方法，使用readall()读取数据时，无论设置多大的buffer size，无论发送多大的数据包过去，命令始终卡着，无任何输出，即使携带上回车换行也没有效果。





### 十六进制显示

十六进制显示的实质是把接收到的字符串转换成其对应的ASCII码，然后将ASCII码值再转换成十六进制数显示出来，这样就可以显示特殊字符了。

在这里定义了一个函数，如hexShow(argv)，代码如下：



```
#!/usr/bin/env python
# -*- coding:UTF-8 -*

import serial


def hexShow(argv):
    result = ''
    hLen = len(argv)
    for i in xrange(hLen):
        hvol = ord(argv[i])
        hhex = '%02x'%hvol
        result += hhex+' '

    print 'hexShow:', result

ser = serial.Serial('COM8',9600)
str_input = raw_input('Enter some words:')
writen_str = ser.write(str_input)
print &quot;--  writen_str : ({})&quot;.format(writen_str)

read_str = ser.read(writen_str)
print &quot;--  read_str : ({})&quot;.format(read_str)

hexShow(read_str)

ser.close()
```



测试结果如下：

```
C:\Users\Administrator&gt;python C:\Users\Administrator\Desktop\hexShow.py
Enter some words:hex shows test
--  writen_str : (14)
--  read_str : (hex shows test)
hexShow: 68 65 78 20 73 68 6f 77 73 20 74 65 73 74
```





### 十六进制发送



十六进制发送实质是发送十六进制格式的字符串，如'\xaa'，'\x0b'。重点在于怎么样把一个字符串转换成十六进制的格式，有两个误区：

1）'\x'+'aa'是不可以的，涉及到转义符反斜杠

2）'\x'+'aa'和r'\x'+'aa'也不可以的，这样的打印结果虽然是\xaa，但赋给变量的值却是'\xaa'



这里用到decode函数：



```
&gt;&gt;&gt; s ='aabbccddee'
&gt;&gt;&gt; s.decode('hex')
'\xaa\xbb\xcc\xdd\xee'
&gt;&gt;&gt;
```



需要注意一点，如果字符串 s 的长度为奇数，则decode会报错：

```
&gt;&gt;&gt; s ='aabbccdde'
&gt;&gt;&gt; s.decode('hex')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;C:\Python27\lib\encodings\hex_codec.py&quot;, line 42, in hex_decode
    output = binascii.a2b_hex(input)
TypeError: Odd-length string
&gt;&gt;&gt;
```



可以按照实际情况，用字符串的切片操作，在字符串的开头或结尾加一个'0'。



假如在串口助手以十六进制发送字符串&quot;abc&quot;，那么你在python中则这样操作：

```serial.write(”\x61\x62\x63&quot;) ```



当然，还有另外一个方法也可以达到相同目的：

```
s = &quot;abc&quot;
strHex = binascii.b2a_hex(s)
# print strHex
strhex = strHex.decode(&quot;hex&quot;)
# print strhex
ser.write(strhex);
```





### 读取串口记录的最后一行



```
    def read_last_line(self):
        &quot;&quot;&quot;
        Read the last line of output of serial, if not match, return None
        &quot;&quot;&quot;
        all_line = self.serial.read_all().decode('GBK')
        logging.debug(&quot;--  [DEBUG]  all_line : ({})&quot;.format(all_line))
        all_line_list = [x for x in all_line.split('\n') if x]
        if len(all_line_list):
            return all_line_list[-1]
        else:
            return
```





### 判断 buffer 是否有内容



```
    def has_buffer(self):
        &quot;&quot;&quot;
        Get serial buffer
        @return: True or False
        &quot;&quot;&quot;
        if self.serial.in_waiting &gt; 0:
            buffer_size = self.serial.in_waiting
            time.sleep(5)
            current_buffer_size = self.serial.in_waiting
            if buffer_size != current_buffer_size:
                return True
        else:
            return False
```





### 读取串口内容并记录到文件



```
    def write_serial_output_to_file(self, file_name):
        &quot;&quot;&quot;
        Write serial output into a file
        @param file_name: string, a file name which to record the serial output information
        &quot;&quot;&quot;
        logging.debug('--  [DEBUG]  Write data into file : (%s)', file_name)

        while True:
            if self.serial.in_waiting &gt; 0:  # If serial has data to read
                full_data = self.serial.readline().decode('GBK').strip()
                # split_data = full_data.splitlines()
                with open(file_name, 'a+') as f:
                    f.write(full_data)
```





### 读取串口内容直到匹配到预期字符串



```
    def read_until_matched(self, key_words):
        &quot;&quot;&quot;
        Get some info when read from serial until match some key words
        @return:
        &quot;&quot;&quot;
        logging.debug(&quot;--  Get key words : (%s) from serial cache&quot;, key_words)

        matched = self.serial.read_until(key_words).decode('GBK')

        return matched
```</content><author><name>Gavin</name></author><category term="python" /><category term="serial" /><summary type="html">概述</summary></entry><entry><title type="html">Windows下pyserial嵌入式自动化测试框架</title><link href="http://0.0.0.0:4000/2023/07/19/pyseral_automation/" rel="alternate" type="text/html" title="Windows下pyserial嵌入式自动化测试框架" /><published>2023-07-19T00:00:00+08:00</published><updated>2023-07-19T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2023/07/19/pyseral_automation</id><content type="html" xml:base="http://0.0.0.0:4000/2023/07/19/pyseral_automation/"># 概述

本文介绍如何基于 python + pytest + pyserial + allure，完成嵌入式产品自动化框架的设计与用例编写。


# 预期目标

* 有可视化报告输出，展示被测版本信息、串口ID，以及运行过程中日志，包括但不限制于串口的输入与输出信息
* 根据产测工具输入的命令行，解析串口输出数据，校验输出结果是否符合预期要求，如果满足要求，则判断此测试项测试通过；否则测试项测试失败
* 细化每一个测试程序的每一个测试项与测试子项，封装成独立函数，便于后期用例组合参数完成用例功能设计工作
* 支持指定用例或用例集合下测试用例的执行
* 支持指定用例执行次数，默认1次
* 先兼容一个产品，再逐步兼容其他产品，优先打磨框架



# 设计思路


理应画个设计思路与流程图的，比较懒，略了吧......



# 基础环境安装/部署


windows下安装python2.x系列，由于python lib有相互依赖关系，本文介绍python-2.7.13下部署pytest。

所需安装包信息，参考下文信息(不全，仅展示部分重要lib)。



## pytest相关基础包

```
allure-pytest-2.8.11
allure-python-commons-2.8.11
allure-commandline-2.13.2
configobj-4.7.2
coverage-5.1
func_timeout-4.3.5
pylint-1.7.6
pytest-4.6.11
pytest-progress-1.2.1
pytest-repeat-0.8.0
pytest-ordering-develop
```



安装成功后，显示如下信息，表明安装成功：

```
E:\automation\src&gt;pytest --version
This is pytest version 4.6.11, imported from C:\Python27\lib\site-packages\pytest.pyc
setuptools registered plugins:
  pytest-cov-2.12.1 at C:\Python27\lib\site-packages\pytest_cov\plugin.py
  pytest-timeout-1.3.4 at C:\Python27\lib\site-packages\pytest_timeout-1.3.4-py2.7.egg\pytest_timeout.pyc
  pytest-ordering-0.6 at C:\Python27\lib\site-packages\pytest_ordering-0.6-py2.7.egg\pytest_ordering\__init__.pyc
  pytest-progress-1.2.1 at C:\Python27\lib\site-packages\pytest_progress-1.2.1-py2.7.egg\pytest_progress.pyc
  pytest-repeat-0.8.0 at C:\Python27\lib\site-packages\pytest_repeat-0.8.0-py2.7.egg\pytest_repeat.pyc
  allure-pytest-2.8.11 at C:\Python27\lib\site-packages\allure_pytest-2.8.11-py2.7.egg\allure_pytest\plugin.pyc

E:\automation\src&gt;
```



## java相关安装包

```
jdk-8u171-windows-x64
```


安装好 JRE 后，配置 windows下 allure 环境变量信息，让 windows 的 dos 命令或 PowerShell 能够识别到allure命令。出现如下信息，说明 allure 始终正常：

&lt;img class=&quot;shadow&quot; src=&quot;/img/in-post/serial/allure_help.png&quot; width=&quot;1200&quot;&gt;



# 框架目录结构


## 整体目录结构介绍


```
 E:\automation 的目录

2023/07/19  10:31    &lt;DIR&gt;          .
2023/07/19  10:31    &lt;DIR&gt;          ..
2023/07/19  10:44    &lt;DIR&gt;          doc
2023/07/19  10:37    &lt;DIR&gt;          report
2023/07/19  10:36    &lt;DIR&gt;          src
               0 个文件              0 字节
               8 个目录 459,405,893,632 可用字节

E:\automation&gt;
```


说明：

* doc 目录下存放一些介绍文档，包括但不限制于当前框架使用说明、用例编写规范说明、pytest 框架介绍等
* report 目录下存放生成的 allure 报告，主体内容以 json 格式存放，借助allure 生成可视化html报告
* src 目录存放源码，为框架核心内容



## report目录介绍

```
E:\automation\report&gt;dir
 驱动器 E 中的卷没有标签。
 卷的序列号是 EE05-33CD

 E:\automation\report 的目录

2023/07/19  10:37    &lt;DIR&gt;          .
2023/07/19  10:37    &lt;DIR&gt;          ..
2023/07/19  10:36            31,765 coverage.xml
2023/07/19  10:37    &lt;DIR&gt;          html
2023/07/19  10:36    &lt;DIR&gt;          json
2023/07/19  10:31             4,842 pylint.out
2023/07/19  10:36             9,271 pytest_autotest.log
2023/07/19  10:31                13 version.txt
               4 个文件         45,891 字节
               4 个目录 459,405,893,632 可用字节

E:\automation\report&gt;
```


说明：

* coverage.xml 为 当前测试用例代码覆盖率统计信息，供 CI/CD 解析使用
* html 目录为 allure 可视化报告
* json 目录为生成的 allure 原始报告数据
* pylint.out 文件为当前测试框架 python 代码相关规范、语法统计信息，供 CI/CD 解析使用
* pytest_autotest.log 文件为用例执行过程中记录的日志信息
* version.txt 文件记录被测版本信息，用于 allure 生成 html 测试报告展示版本信息使用



## src目录介绍



```
E:\automation\src&gt;dir
 驱动器 E 中的卷没有标签。
 卷的序列号是 EE05-33CD

 E:\automation\src 的目录

2023/07/19  11:09    &lt;DIR&gt;          .
2023/07/19  11:09    &lt;DIR&gt;          ..
2023/06/25  16:37            17,584 .pylintrc
2023/06/25  16:37               579 clear_pyc.py
2023/07/19  11:09    &lt;DIR&gt;          common
2023/07/14  15:34    &lt;DIR&gt;          config
2023/06/25  16:37               806 conftest.py
2023/06/26  14:44               647 pytest.ini
2023/07/17  17:18             7,626 run.py
2023/07/19  11:09    &lt;DIR&gt;          testcase
2023/07/19  11:09    &lt;DIR&gt;          testcasebase
2023/06/25  16:37                 0 __init__.py
               7 个文件         47,722 字节
               6 个目录 459,405,946,880 可用字节

E:\automation\src&gt;dir common
 驱动器 E 中的卷没有标签。
 卷的序列号是 EE05-33CD

 E:\automation\src\common 的目录

2023/07/19  11:09    &lt;DIR&gt;          .
2023/07/19  11:09    &lt;DIR&gt;          ..
2023/07/11  14:58               804 config.py
2023/06/25  16:37               711 path_util.py
2023/07/19  09:31             6,410 pyserial.py
2023/07/19  11:09    &lt;DIR&gt;          tools
2023/07/18  17:28             7,813 util.py
2023/06/25  16:37                 0 __init__.py
               5 个文件         15,738 字节
               3 个目录 459,405,946,880 可用字节

E:\automation\src&gt;dir config
 驱动器 E 中的卷没有标签。
 卷的序列号是 EE05-33CD

 E:\automation\src\config 的目录

2023/07/14  15:34    &lt;DIR&gt;          .
2023/07/14  15:34    &lt;DIR&gt;          ..
2023/07/14  15:34               160 autotest.config
               1 个文件            160 字节
               2 个目录 459,405,946,880 可用字节

E:\automation\src&gt;dir testcase
 驱动器 E 中的卷没有标签。
 卷的序列号是 EE05-33CD

 E:\automation\src\testcase 的目录

2023/07/19  11:09    &lt;DIR&gt;          .
2023/07/19  11:09    &lt;DIR&gt;          ..
2023/06/25  16:37               364 conftest.py
2023/07/19  10:25               980 test_01_comprehensive_test.py
2023/07/18  18:43                30 test_02_watch_dog.py
2023/07/19  10:26             1,468 test_03_electronic_disk.py
2023/06/25  16:37                 0 __init__.py
               7 个文件          4,393 字节
               2 个目录 459,405,946,880 可用字节

E:\automation\src&gt;dir testcasebase
 驱动器 E 中的卷没有标签。
 卷的序列号是 EE05-33CD

 E:\automation\src\testcasebase 的目录

2023/07/19  11:09    &lt;DIR&gt;          .
2023/07/19  11:09    &lt;DIR&gt;          ..
2023/07/19  10:30             1,696 ComprehensiveTest.py
2023/07/19  10:28             5,722 ElectronicDisk.py
2023/07/19  10:24             2,552 ProductInit.py
2023/07/18  17:30               335 WatchDog.py
2023/06/25  16:37                 0 __init__.py
               5 个文件         10,305 字节
               2 个目录 459,405,946,880 可用字节

E:\automation\src&gt;
```



说明：

* common 目录，存放公用基类
* config 目录，存放配置信息，诸如设置的串口信息，波特率等
* run.py 是程序主入口，支持根据传参执行全部用例与部分用例
* testcase 目录存放具体的测试用例
* testcasebase 目录存放各个功能的基类



# 框架核心内容


重点在pyserial串口操作上，以及各个功能点的基类中发送串口命令、解析串口命令、判断串口输出结果正确与否。



pyserial 部分代码如下：


```
#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;  pyserial operation  &quot;&quot;&quot;

from __future__ import unicode_literals

import sys
import glob
import json
import time
import serial
import logging

from config import  GetConfig as config
from util import change_timestamp_to_time


class PySerial():
    def __init__(self, send_str=&quot;Send Test&quot;, receive=&quot;Send Test&quot;, timeout=0.2):
        self.port = config.port
        self.baudrate = config.baudrate
        self.send_str = send_str
        self.receive = receive
        self.timeout = timeout
        self.serial = None

    @staticmethod
    def list_serial_ports():
        &quot;&quot;&quot;
        Lists serial port names
        :raises EnvironmentError:   On unsupported or unknown platforms
        :returns: A list of the serial ports available on the system
        &quot;&quot;&quot;
        if sys.platform.startswith('win'):
            ports = ['COM%s' % (i + 1) for i in range(256)]
        elif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'):
            # this excludes your current terminal &quot;/dev/tty&quot;
            ports = glob.glob('/dev/tty[A-Za-z]*')
        elif sys.platform.startswith('darwin'):
            ports = glob.glob('/dev/tty.*')
        else:
            raise EnvironmentError('Unsupported platform')
    
        result = []
        for port in ports:
            try:
                s = serial.Serial(port)
                s.close()
                result.append(port)
            except (OSError, serial.SerialException):
                pass
    
        return result

    def serial_alive(self):
        &quot;&quot;&quot;   If port alive, return True, else return False   &quot;&quot;&quot;
        port_status = False

        if self.serial.isOpen():
            port_status = True

        return port_status

    def connect(self, check_loop_send=False):
        &quot;&quot;&quot;
            Connect to the serial port
            :param check_loop_send， bool， True means send and receive message from COM1 to COM1 in cc=ycle
        &quot;&quot;&quot;
        try:
            self.serial = serial.Serial(self.port, self.baudrate, timeout=self.timeout)
            if check_loop_send:
                self.check_device()
        except Exception as ex:
            logging.error(&quot;[ERROR]  Port: (%s), baudrate: (%s), timeout: (%s)&quot;, self.port,
                          self.baudrate, self.timeout)
            logging.error(&quot;[ERROR]  Connect to serial failed, backend return : (%s)&quot;, str(ex))
            sys.exit(1)

        return self.serial

    def check_device(self):
        &quot;&quot;&quot;  Check the device  &quot;&quot;&quot;
        write_len = self.serial.write(self.send_str.encode('GBK'))
        logging.debug(&quot;--   write_len: %s&quot;, write_len)
        serial.time.sleep(0.1)
        byteData = self.serial.read(write_len).decode('GBK')
        logging.debug(&quot;--  self.send_str : (%s)&quot;, self.send_str)
        logging.debug(&quot;--  byteData : (%s)&quot;, byteData)
        if byteData != self.receive.encode('GBK'):
            raise ValueError(&quot;Check Device Failed:send_str: '{}' not equal to receive: '{}', &quot;
                             &quot;actually receive : '{}'&quot;.format(self.send_str, self.receive, byteData))

    def write(self, cmd_str):
        &quot;&quot;&quot;  Send command  &quot;&quot;&quot;
        # Clean the input buffer, clean the return values
        self.serial.reset_input_buffer()

        logging.debug(&quot;--  [DEBUG]  Write command string : (%s)&quot;, cmd_str)
        self.serial.write((cmd_str + '\r\n').encode('GBK'))

    def read(self, count=None, all_data=False, flush_flag=False):
        &quot;&quot;&quot;  Read the data, count Unit is byte, default is 1 byte  &quot;&quot;&quot;
        logging.debug('--  [DEBUG]  Read count : (%s), all_data : (%s)', count, all_data)

        if flush_flag:
            # Flush current serial cache, if clean cache, can call serial.readline() to get new data
            self.serial.flushInput()

        # Enlarge the buffer, default is 4096bytes, if the output which is larger than 4096bytes,
        # call read_all() only get 4096bytes content, max is 2147483647(but not works, so set it less)
        self.serial.set_buffer_size(rx_size=2147483600, tx_size=2147483600)

        if all_data:
            return self.serial.read_all().decode('GBK')
        else:
            count = 1 if count is None else count
            return self.serial.read(count).decode('GBK')

    def read_last_line(self):
        &quot;&quot;&quot;
        Read the last line of output of serial, if not match, return None
        &quot;&quot;&quot;
        self.serial.set_buffer_size(rx_size=2147483600, tx_size=2147483600)
        all_line = self.serial.read_all().decode('GBK')
        logging.debug(&quot;--  [DEBUG]  all_line : ({})&quot;.format(all_line))
        all_line_list = [x for x in all_line.split('\n') if x]
        if len(all_line_list):
            return all_line_list[-1]
        else:
            return

    def write_serial_output_to_file(self, file_name):
        &quot;&quot;&quot;
        Write serial output into a file
        @param file_name: string, a file name which to record the serial output information
        &quot;&quot;&quot;
        logging.debug('--  [DEBUG]  Write data into file : (%s)', file_name)

        self.serial.set_buffer_size(rx_size=2147483600, tx_size=2147483600)

        while True:
            if self.serial.in_waiting &gt; 0:  # If serial has data to read
                full_data = self.serial.readline().decode('GBK').strip()
                # split_data = full_data.splitlines()
                with open(file_name, 'a+') as f:
                    f.write(full_data)

    def has_buffer(self):
        &quot;&quot;&quot;
        Get serial buffer
        @return: True or False
        &quot;&quot;&quot;
        # self.serial.set_buffer_size(rx_size=2147483600, tx_size=2147483600)
        logging.debug(&quot;--  [DEBUG]  ser.in_waiting : (%s)&quot;, self.serial.in_waiting)
        if self.serial.in_waiting &gt; 0:
            buffer_size = self.serial.in_waiting
            logging.debug('--  [DEBUG]  buffer size : (%s)', buffer_size)
            time.sleep(15)
            current_buffer_size = self.serial.in_waiting
            logging.debug('---  [DEBUG]  current buffer size : (%s)', current_buffer_size)
            if buffer_size != current_buffer_size:
                return True
        else:
            logging.debug('--  [DEBUG]  Enter else, return False, has no serial buffer')
            return False

    def close(self):
        &quot;&quot;&quot;  Close serial connection  &quot;&quot;&quot;
        self.serial.close()
```



# 用例编写基本规则要求


## 1. 能编写但需要延迟编写的用例，增加 raise SkipTest 


如果两个功能之间有依赖，某个功能尚未编码结束，先写了其中一个功能，另外一个功能需要先标记成skip状态，这样做的目的： 

* 意在提醒 skip 状态的用例要在将来被完成 
* 某些用例需要手工执行上下电动作，只能手工测试，需要增加skip



## 2. Base Class 里，禁止函数名称含有 test  

pytest 运行用例的时候，根据正则匹配测试用例，会匹配到含有 test 开头的函数，会认为这个函 数是一个测试用例，故而要避免此种情况的发生，如果一定要在基类里写test，可以使用单词 examination 代替。



## 3. test_xx.py 无逻辑内容


test_xxxx.py是用例集，此用例集里纯粹是函数的调用，无任何业务逻辑，业务逻辑全部在testcasebase里。


## 4. 测试用例名称携带编号  


用例需携带上 \__doc__，此信息为用例Title， 且以服务器上（如TestLink）记录的名称为准。

例如： 

``` test_143_same_daemon_different_signal ```

对应 TestLink 的用例为：

``` FC-143:Same daemon, different signal core file ```



## 5. 测试用例的\__doc__，不得含有中文字符  


例如： ``` FC-143:Same daemon，different signal core file ``` 这里的逗号，是中文符号，会导致用例报错。



## 6、避免测试用例之间存在依赖关系 


* 每个测试 suite 中的测试用例互相不依赖
* 测试 suite 中的用例，尽可能避免依赖关系，如 TestLink 中上一个用例是创建，下一个用例是删除，则合并这两个用例为一个自动化测试用例。 



## 7、日志记录对齐要求  


为了让记录的log内容看起来更对其，对于code中的日志记录，规则要求如下：

* 执行动作的记录，开头增加[Action]
* 检查动作的记录，开头增加[Check]
* 断言记录的 log，开头增加[ERROR]
* 操作成功的 log，开头增加[SUCCESS]
* 不需要检查点 的，开头增加[Skip]



具体要求如下： 

* [Prepare] 后面跟 2 个空格
* [Action] 后面跟 3 个空格
* [Start] 后面跟 4 个空格
* [Check] 后面跟 4 个空格
* [Success] 后面跟 2 个空格
* [Skip] 后面跟 5 个空格
* debug 级别的 log，内容前面跟 2 个-，之后 再加 2 个空格
* assert 中，[ERROR] 后面跟 2 个空格 



## 8、用例的执行顺序 


pytest用例执行顺序，根据 ASSII 进行排序，单个用例文件中则是以用例编写先后顺序执行。

在用例有关联情 况下，需要对用例名称增加数字编号，人为的干预用例执行顺序，比如 test_1_xxx, test_2_yyy；或者借助pytest-order plugin来约束住用例见关系。



## 9、代码规范要求


执行 pylint，确保检查结果分值等于10, e.g :

```pylint -r y common/pyserial.py --rcfile=.pylintrc```


&lt;img class=&quot;shadow&quot; src=&quot;/img/in-post/serial/run-pylint.png&quot; width=&quot;1200&quot;&gt;


MESSAGE_TYPE 有如下几种： 

(C) 惯例，违反了编码风格标准 

(R) 重构，写得非常糟糕的代码

(W) 警告，某些 Python 特定的问题

(E) 错误，很可能是代码中的错误

(F) 致命错误，阻止 Pylint 进一步运行的错误




## 10. 用例文件名称、用例中定义变量名称全局唯一 


对于测试用例中定义的变量，要保持全局唯一，当有用例出错时，可以根据这个名称，定位到是哪个用例产生了问题，因为具有唯一性，可以排除其他用例带来的干扰，尤其对于用例规模上千后，此笨方法会比较有效。

当有用例出错时，可以根据这个名称，定位到是哪个用例产生了问题，因为具有唯一性，可以排除其他用例带来的干扰。




# 用例编写


测试用例仅仅是逻辑的调用，组合各个函数，构造成一个完整的测试场景。

这里以电子盘测试为示例，参考如下：



```test_03_electronic_disk.py ``` 内容参考如下：



```
#!/usr/bin/env python
# -*- coding: GBK -*-

&quot;&quot;&quot;  Check output of electronic disk test information  &quot;&quot;&quot;

from __future__ import unicode_literals

import allure

from src.common.pyserial import PySerial
from src.testcasebase.ElectronicDisk import ElectronicDiskTest


class TestElectronicDiskTest(ElectronicDiskTest):
    &quot;&quot;&quot;    Test case of electronic disk test   &quot;&quot;&quot;
    serial = PySerial()

    def setup(self):
        with allure.step(&quot;连接到串口&quot;):
            self.serial.connect()

    def teardown(self):
        with allure.step(&quot;关闭串口连接&quot;):
            self.serial.close()

    def test_electronic_disk(self):
        with allure.step(&quot;输入 '1' 开始电子盘测试&quot;):
            self.check_electronic_disk_test_menu()

    def test_filesystem_performance(self):
        with allure.step(&quot;电子盘测试 --&gt; 1.电子盘文件系统读写性能测试&quot;):
            self.data_storage_filesystem_read_write_performance_test()

    def test_emcc_performance(self):
        with allure.step(&quot;电子盘测试 --&gt; 2.EMMC多任务读写测试&quot;):
            self.emmc_multi_task_read_write_test()

    def test_data_encry_performance_test(self):
        with allure.step(&quot;电子盘测试 --&gt; 3.电子盘文件系统数据加密解密性能测试&quot;):
            self.data_encry_test()

    def test_folder_files_created_performance_test(self):
        with allure.step(&quot;电子盘测试 --&gt; 4.电子盘文件夹与文件数创建性能测试&quot;):
            self.folder_file_created_performance()
```



非常明显的看出来，这里没有逻辑，完全是具体函数的调用。对应测试项功能的发起、返回结果的校验，完全在被调用函数里，所以，框架的另外一个重心，就是各个功能点的基类函数。



# 用例执行


## 执行全部用例


src 目录下，执行 ```python run.py```, 如下所示：


```
E:\automation\src&gt;python run.py
--------------------------------------------------------------------------------
[Step 1]  [Check]    Check if the report directory is deleted

          [SKIP]     No need to delete report directory
--------------------------------------------------------------------------------
[Step 2]  Check test case execution node.

    2-1 [Check]    Current node should install python, pyest

        [Success]  List some serial ports success

    2-2 [Check]    Should be able to access the serial ports

        [Success]  Access serial port : (COM7) success

--------------------------------------------------------------------------------
[Step 3]  Start to run test case

    3-1 Start to run all of test case

============================= test session starts =============================
platform win32 -- Python 2.7.13, pytest-4.6.11, py-1.11.0, pluggy-0.13.1 -- C:\Python27\python.exe
cachedir: .pytest_cache
rootdir: E:\automation\src, inifile: pytest.ini
plugins: cov-2.12.1, timeout-1.3.4, ordering-0.6, progress-1.2.1, repeat-0.8.0, allure-pytest-2.8.11
collected 11 items

testcase/test_01.py::test_a PASSED                                      [ 1/11]
_ 1 of 11 completed, 1 Pass, 0 Fail, 0 Skip, 0 XPass, 0 XFail, 0 Error, 0 ReRun _

testcase/test_01.py::test_b PASSED                                      [ 2/11]
_ 2 of 11 completed, 2 Pass, 0 Fail, 0 Skip, 0 XPass, 0 XFail, 0 Error, 0 ReRun _

testcase/test_01.py::TestFramework::test_eq PASSED                      [ 3/11]
_ 3 of 11 completed, 3 Pass, 0 Fail, 0 Skip, 0 XPass, 0 XFail, 0 Error, 0 ReRun _

testcase/test_01.py::TestFramework::test_not_eq PASSED                  [ 4/11]
_ 4 of 11 completed, 4 Pass, 0 Fail, 0 Skip, 0 XPass, 0 XFail, 0 Error, 0 ReRun _

testcase/test_01_comprehensive_test.py::TestComprehensiveTest::test_comprehensive

---------- coverage: platform win32, python 2.7.13-final-0 -----------
Coverage XML written to file ../report/coverage.xml
```


## 执行部分用例


执行 ```python run.py -t xxx yyy zzz```， 其中xxx yyy zzz表示不同的用例文件

```
E:\automation\src&gt;python run.py -t testcase/test_01_comprehensive_test.py testcase/test_02_watch_dog.py
```


## 执行某个测试用例


方法1： run.py为入口

e.g:

```
python run.py -t testcase/test_01_comprehensive_test.py::TestComprehensiveTest::test_comprehensive
```


&lt;img class=&quot;shadow&quot; src=&quot;/img/in-post/serial/run_single_case_1.png&quot; width=&quot;1200&quot;&gt;



方法2： pytest命令行执行

e.g:

```
pytest --cov-report xml:../report/coverage.xml --cov=./ --cov-config .coveragerc --alluredir ../report/json testcase/test_01_comprehensive_test.py::TestComprehensiveTest::test_comprehensive
```


&lt;img class=&quot;shadow&quot; src=&quot;/img/in-post/serial/run_single_case_2.png&quot; width=&quot;1200&quot;&gt;





## 循环执行用例



用例执行有多种方式，一是指定整个py文件，而是指定到具体测试用例，无论哪种方式，携带上--count，示例如下：



### 某个用例循环多次执行



```
E:\automation\src&gt;pytest --cov-report xml:../report/coverage.xml --cov=./ --cov-config .coveragerc --alluredir ../report/json testcase/test_01_comprehensive_test.py::TestComprehensiveTest::test_comprehensive --count=10
```


&lt;img class=&quot;shadow&quot; src=&quot;/img/in-post/serial/case_counts.png&quot; width=&quot;1200&quot;&gt;





### 某个测试集合下用例循环多次执行



```
E:\automation\src&gt;pytest --cov-report xml:../report/coverage.xml --cov=./ --cov-config .coveragerc --alluredir ../report/json testcase/test_01.py --count=10
```


&lt;img class=&quot;shadow&quot; src=&quot;/img/in-post/serial/case_counts-2.png&quot; width=&quot;1200&quot;&gt;





# 测试报告



## HTML可视化报告的展示

run.py运行结束后，会在report目录下生成json目录与文件，执行allure相关命令，生成可视化 html 报告：



```
E:\automation&gt;cd report
E:\automation\report&gt;allure generate json -o html --clean
Report successfully generated to html
E:\automation\report&gt;allure open html -p 11111
Starting web server...
2023-07-19 14:56:21.859:INFO::main: Logging initialized @183ms to org.eclipse.jetty.util.log.StdErrLog
Server started at &lt;http://192.168.56.1:11111/&gt;. Press &lt;Ctrl+C&gt; to exit
```



浏览器打开 ```http://192.168.56.1:11111```地址，预览如下：

&lt;img class=&quot;shadow&quot; src=&quot;/img/in-post/serial/allure_report.png&quot; width=&quot;1200&quot;&gt;


如果 allure 命令生成 report 时，未指定 -p 参数，会随机生成一个未被占用的5位数字的端口号：



```
E:\automation\report&gt;allure open html
Starting web server...
2023-07-19 15:00:17.760:INFO::main: Logging initialized @180ms to org.eclipse.jetty.util.log.StdErrLog
Server started at &lt;http://192.168.56.1:52014/&gt;. Press &lt;Ctrl+C&gt; to exit
```



## 失败用例的检查


html可视化报告中给出哪些用例失败，可根据记录到的log信息进行用例失败检查，判断是产品存在Bug还是用例编写问题。</content><author><name>Gavin</name></author><category term="Automation" /><category term="python" /><category term="pytest" /><category term="serial" /><summary type="html">概述</summary></entry><entry><title type="html">修改默认shell</title><link href="http://0.0.0.0:4000/2023/07/16/Edit_shell/" rel="alternate" type="text/html" title="修改默认shell" /><published>2023-07-16T00:00:00+08:00</published><updated>2023-07-16T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2023/07/16/Edit_shell</id><content type="html" xml:base="http://0.0.0.0:4000/2023/07/16/Edit_shell/"># 概述


今天在Ubuntu22环境下安装LANMP，执行`sh lanmp.sh`命令运行LANMP，如果出现如下错误：

```
root@ubuntu22:~# sh lanmp.sh 
lanmp.sh: 49: lib/common.conf: function: not found
lanmp.sh: 76: lib/common.conf: Syntax error: &quot;}&quot; unexpected
root@ubuntu22:~# 
```

这是因为在Kali或Ubuntu系统中，对dash的兼容性不好，而编译常用的是bash（Ubuntu默认shell是dash,  但是从bash环境拿过来的shell脚本执行就会遇到一些问题）。

这里涉及到更改系统的编辑器(shell)操作，本文介绍之。



# 实践



## 方法1： 交互式修改

输入命令dpkg-reconfigure dash ，然后选择\&lt;NO\&gt;选项：

```js
dpkg-reconfigure dash 
```

&lt;img class=&quot;shadow&quot; src=&quot;/img/in-post/reconfig-shell.png&quot; width=&quot;1200&quot;&gt;


## 方法2：非交互式修改

方法1是交互式的, 但是实际情况用脚本的更多, 所以我们还是用命令修改吧



```
[[ -L /bin/sh ]] &amp;&amp; mv /bin/sh /tmp/.sh$(date +%s)
[[ -f /bin/sh ]] || ln -s /bin/bash /bin/sh
[[ -L /usr/share/man/man1/sh.1.gz ]] &amp;&amp; mv /usr/share/man/man1/sh.1.gz /tmp/.sh.1.gz$(date +%s)
[[ -f /usr/share/man/man1/sh.1.gz ]] || ln -s /usr/share/man/man1/bash.1.gz /usr/share/man/man1/sh.1.gz
```

这些命令就是根据dpkg-reconfigure dash的结果来修改的。</content><author><name>Gavin</name></author><category term="shell" /><summary type="html">概述</summary></entry><entry><title type="html">vim支持黏贴</title><link href="http://0.0.0.0:4000/2023/07/08/vim_copy/" rel="alternate" type="text/html" title="vim支持黏贴" /><published>2023-07-08T00:00:00+08:00</published><updated>2023-07-08T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2023/07/08/vim_copy</id><content type="html" xml:base="http://0.0.0.0:4000/2023/07/08/vim_copy/"># 概述

打开vim进行编辑时，有时候通过类似xshell这样的终端工具，想拷贝vim里的内容或者黏贴内容到vim里，会出现无法黏贴的现象。

虽然可以在vim中直接设置 ':set mouse=a'，但是无法永久生效。为了解决此问题，本文介绍之。


# vim 无法粘贴问题


修改配置文件，找到如下配置文件


``` vim /usr/share/vim/vim90/defaults.vim ```


在81行找到如下内容：

```
if has('mouse')
  if &amp;term =~ 'xterm'
    set mouse=a
  else
    set mouse=nvi
  endif
endif
```



修改为

```html
if has('mouse')
  if &amp;term =~ 'xterm'
    set mouse-=a
  else
    set mouse=nvi
  endif
endif
```



保存退出</content><author><name>Gavin</name></author><category term="shell" /><category term="vim" /><summary type="html">概述</summary></entry><entry><title type="html">S3 Example</title><link href="http://0.0.0.0:4000/2023/06/21/S3_example/" rel="alternate" type="text/html" title="S3 Example" /><published>2023-06-21T00:00:00+08:00</published><updated>2023-06-21T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2023/06/21/S3_example</id><content type="html" xml:base="http://0.0.0.0:4000/2023/06/21/S3_example/">```
#-*-coding:UTF-8-*-

import boto

import boto.s3.connection
import os
from boto.s3.key import Key
access_key ='XX4SO4LP5SDY3DZ0G0KN'
secret_key = 'tvRtXW/ADPUNSw9ccuMWoU1cFu/wJG2QbCOvbX34'


#建立连接
print &quot;createt connection BEGIN \n&quot;
conn = boto.connect_s3(
        aws_access_key_id = access_key,
        aws_secret_access_key = secret_key,
        host = '10.16.17.88',
        #is_secure=False,    #uncomment if you are not using ssl
        calling_format = boto.s3.connection.OrdinaryCallingFormat(),
        )
print conn

print &quot;createt connection  END\n&quot;

#列出所有已有的bucket，以及创建时间
print &quot;list all the bucket in this account, empty of course&quot;
for bucket in conn.get_all_buckets():
    print &quot;{name}\t{created}&quot;.format(
            name = bucket.name,
            created = bucket.creation_date,
            )
print &quot;list all buckets finished\n&quot;

# 查找bucket是否存在
print &quot;create bucket and list all bucket BEGIN&quot;
bucket_name = &quot;my-bucket&quot;
bucket = conn.lookup(bucket_name)
if bucket == None :
    print &quot;bucket {} is not exists&quot;.format(bucket_name)
    # 创建bucket 
    bucket = conn.create_bucket(bucket_name)
    # 再次列出所有的bucket，查看是否存在新建的bucket
    for bucket in conn.get_all_buckets():
        print &quot;{name}\t{created}&quot;.format(
                name = bucket.name,
                created = bucket.creation_date,
                )
    print &quot;create bucket and list all bucket END\n&quot;

#查看bucket中的所有对象
print &quot;list all the OBJECTS in bucket, empty of course&quot;
bucket = conn.lookup(bucket_name)
for key in bucket.list():
    print &quot;{name}\t{size}\t{modified}&quot;.format(
                name = key.name,
                size = key.size,
                modified =
                key.last_modified,
           )
print &quot;list all the OBJECTS in bucket END\n&quot;
   
# 上传对象，对象的内容来自字符串
key_name = &quot;my-object&quot;

print &quot;upload object from string ,and list it &quot;
key = bucket.lookup(key_name)
if key == None:
    print &quot;key {} is not exists in bucket {}&quot;.format(key_name,bucket_name)
    k = Key(bucket)
    k.key = key_name
    k.set_contents_from_string(&quot;this object is generated by string&quot;)
    for key in bucket.list():
        print &quot;{name}\t{size}\t{modified}&quot;.format(
                    name = key.name,
                    size = key.size,
                    modified =
                    key.last_modified,
               )

print &quot;upload object from string ,and list it END\n &quot;

# 上传对象，对象的内容来自文件
key_name = &quot;my-object-from-file&quot;

print &quot;upload object from filename ,and list it &quot;
#需要上传文件的路径，我的例子是Linux的路径，Windows下用文件的路径即可。
filename_need_upload = &quot;/var/log/kern.log&quot;
key = bucket.lookup(key_name)
if key == None:
    print &quot;key {} is not exists in bucket {}&quot;.format(key_name,bucket_name)
    k = Key(bucket)
    k.key = key_name
    k.set_contents_from_filename(filename_need_upload)

    #上传完毕后，列出所有的对象，查看新上传的文件是否存在。
    for key in bucket.list():
        print &quot;{name}\t{size}\t{modified}&quot;.format(
                    name = key.name,
                    size = key.size,
                    modified =
                    key.last_modified,
               )

print &quot;upload object from file ,and list it END\n&quot;
# 下载刚刚上传的对象 
key_name = &quot;my-object-from-file&quot;
filename_of_download = &quot;/tmp/kern.log.bak&quot;


print &quot;download object to file string ,and check file &quot;
key = bucket.get_key(key_name)
key.get_contents_to_filename(filename_of_download)

if os.path.isfile(filename_of_download):
    print &quot;{} is file ,download successfully&quot;.format(filename_of_download)

print &quot;download object to file string ,and check file END\n &quot;


# 删除bucket中的某个对象

key_name = &quot;my-object-from-file&quot;
bucket.delete_key(key_name)

# 删除之后查看对应的key 是否存在
for key in bucket.list():
    print &quot;{name}\t{size}\t{modified}&quot;.format(
                name = key.name,
                size = key.size,
                modified =
                key.last_modified,
           )

# 删除bucket中所有的objcet
for key in bucket.list():
    bucket.delete_key(key.name)

# 删除bucket
bucket_name = &quot;my-bucket&quot;
conn.delete_bucket(bucket_name)

```


```
#!/usr/bin/env python
#-*-coding:UTF-8-*-

import boto3

s3_client = boto3.client('10.16.17.11:8080')
open('hello.txt').write('Hello, world!')

# Upload the file to S3
s3_client.upload_file('hello.txt', 'BUCKET', 'hello-remote.txt')

# Download the file from S3
s3_client.download_file('BUCKET', 'hello-remote.txt', 'hello2.txt')
print(open('hello2.txt').read())

```</content><author><name>Gavin</name></author><category term="S3" /><category term="python" /><summary type="html">``` #--coding:UTF-8--</summary></entry><entry><title type="html">获取WIFI密码</title><link href="http://0.0.0.0:4000/2023/06/07/Show_WIFI_password/" rel="alternate" type="text/html" title="获取WIFI密码" /><published>2023-06-07T00:00:00+08:00</published><updated>2023-06-07T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2023/06/07/Show_WIFI_password</id><content type="html" xml:base="http://0.0.0.0:4000/2023/06/07/Show_WIFI_password/"># 概述

已经连上过WIFI，忘记了密码，有新的电脑设备要加入，如何快速获取WIFI密码，本文介绍wlan命令，通过wlan命令获取WIFI密码。


# 实践

```
Microsoft Windows [版本 10.0.19045.2965]
(c) Microsoft Corporation。保留所有权利。

C:\Users\Gavin&gt;netsh
netsh&gt;wlan show profile

接口 WLAN 上的配置文件:


组策略配置文件(只读)
---------------------------------
    &lt;无&gt;

用户配置文件
-------------
    所有用户配置文件 : wifiYang_5G
    所有用户配置文件 : strayeagle_5G

netsh&gt;
```

		
```
netsh&gt;wlan show profile name=&quot;strayeagle_5G&quot; key=clear

接口 WLAN 上的配置文件 strayeagle_5G:
=======================================================================

已应用: 所有用户配置文件

配置文件信息
-------------------
    版本                   : 1
    类型                   : 无线局域网
    名称                   : strayeagle_5G
    控制选项               :
        连接模式           : 自动连接
        网络广播           : 只在网络广播时连接
        AutoSwitch         : 请勿切换到其他网络
        MAC 随机化: 禁用

连接设置
---------------------
    SSID 数目              : 1
    SSID 名称              :“strayeagle_5G”
    网络类型               : 结构
    无线电类型             : [ 任何无线电类型 ]
    供应商扩展名           : 不存在

安全设置
-----------------
    身份验证         : WPA2 - 个人
    密码                 : CCMP
    身份验证         : WPA2 - 个人
    密码                 : GCMP
    安全密钥               : 存在
    关键内容            : HelloPasswordTest123!

费用设置
-------------
    费用                : 无限制
    阻塞                : 否
    接近数据限制        : 否
    过量数据限制        : 否
    漫游                : 否
    费用来源            : 默认

netsh&gt;
```


**说明：**

* 此处的 &quot;关键内容            : HelloPasswordTest123!&quot;，即为wifi的密码.</content><author><name>Gavin</name></author><category term="WIFI" /><summary type="html">概述</summary></entry><entry><title type="html">fio 校验文件写完整性</title><link href="http://0.0.0.0:4000/2023/06/07/fio_verify/" rel="alternate" type="text/html" title="fio 校验文件写完整性" /><published>2023-06-07T00:00:00+08:00</published><updated>2023-06-07T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2023/06/07/fio_verify</id><content type="html" xml:base="http://0.0.0.0:4000/2023/06/07/fio_verify/"># 概述

今天在整理电脑，发现了之前写的一个利用fio，模拟ceph集群发生OSD Down、UP期间，数据写入内容准确性校验，是否存在业务持续写入过程中，ceph集群发生异常，引发数据丢失的可能。


# 实践


脚本分为三部分，一部分是fio写，一部分是 restart ceph-osd，最后一部分是校验fio写文件内容准确性。


```
run_fio.py
restart_osd.py
check_fio.py
```


## run_fio.py

```
import time

from ezs3.command import do_cmd


fio_cmd = &quot;fio --name=verify --rw=write --bssplit=128k/30:256k/30:512k/20:1m/20 --size=100G --numjobs=32 --ioengine=libaio --iodepth=16 --direct=1 --group_reporting --verify=md5 --filename=/dev/rbd0 --loops=1000&quot;

for i in xrange(100):
    print &quot;------- {} times to run fio  -------&quot;.format(i)
    do_cmd(fio_cmd)
    time.sleep(15)
```


## restart_osd.py


```
import time
import random

import logging
from ezs3.log import EZLog

from ezs3.cluster import ClusterManager
from ezs3.command import do_cmd

EZLog.init_handler(logging.INFO, &quot;/root/osd_random_restart.log&quot;)
logger = EZLog.get_logger(&quot;restart_osd&quot;)


def get_osd_id_ip_map():
    &quot;&quot;&quot;  Get all of OSD id  &quot;&quot;&quot;
    osd_id_ip_map = {}
    all_osds_set = ClusterManager().get_osds()[-1]
    
    for key in all_osds_set:
        osd_id_ip_map[key.id] = key.ip

    logger.info(&quot;Get all of OSD id and ip mapping information : (%s)&quot;, osd_id_ip_map)
    return osd_id_ip_map


def get_osd_id(osd_id_ip_map):
    &quot;&quot;&quot;  Get a OSD id by random  &quot;&quot;&quot;
    slice_list = random.sample(osd_id_ip_map.keys(), 1)
    osd_id = slice_list[0]
    ip = osd_id_ip_map[osd_id]

    return osd_id, ip


def restart_osd(osd_id_ip_map, sleep_time=None):
    &quot;&quot;&quot;  Restart the OSD  &quot;&quot;&quot;
    sleep_time = 1800 if sleep_time is None else sleep_time

    for i in xrange(100):
        osd_id_ip_info = get_osd_id(osd_id_ip_map)
        osd_id = osd_id_ip_info[0]
        ip = osd_id_ip_info[1]

        logger.info(&quot;Will restart OSD : (%s), then sleep : (%s)&quot;, osd_id, sleep_time)
        cmd = &quot;ssh {} /etc/init.d/ceph restart osd.{}&quot;.format(ip, osd_id)
        logger.info(&quot;Restart osd cmd is : (%s)&quot;, cmd)
        do_cmd(cmd, 300)
        time.sleep(sleep_time)


if __name__ == &quot;__main__&quot;:
    all_osds = get_osd_id_ip_map()
    restart_osd(all_osds)
```


## check_fio.py

```
import sys
import time
import logging

from ezs3.log import EZLog
from ezs3.command import do_cmd

EZLog.init_handler(logging.INFO, &quot;/root/read_check.log&quot;)
logger = EZLog.get_logger(&quot;check_fio&quot;)

fio_cmd = &quot;fio --name=verify --rw=read --bssplit=128k/30:256k/30:512k/20:1m/20 --size=100G --numjobs=32 --ioengine=libaio --iodepth=16 --direct=1 --group_reporting --verify=md5 --filename=/dev/rbd0 &gt; /root/fio_output.txt&quot;


def fio_read_verify(sleep_time=None):
    &quot;&quot;&quot;  FIO read verify  &quot;&quot;&quot;
    sleep_time = 600 if sleep_time is None else sleep_time

    for i in xrange(10000):
        do_cmd(fio_cmd)
        fio_output = do_cmd(&quot;cat /root/fio_output.txt | grep 'err='&quot;, 60).strip()
        err = fio_output.split(&quot;err=&quot;)[1].split()[0]
        print(&quot;--  err is : ({})&quot;.format(err))
        if int(err) &gt; 0:
            logger.error(&quot;[ERROR]  Find error in fio result when read verify&quot;)
            sys.exit(0)
        else:
            logger.info(&quot;Continue to sleep : (%s)&quot;, sleep_time)
            time.sleep(sleep_time)


if __name__ == &quot;__main__&quot;:
    fio_read_verify()

```</content><author><name>Gavin</name></author><category term="ceph" /><category term="python" /><category term="fio" /><summary type="html">概述</summary></entry><entry><title type="html">统计NAS写入速度(Base on oceanfile tool)</title><link href="http://0.0.0.0:4000/2023/06/06/calc_NAS_write_speed/" rel="alternate" type="text/html" title="统计NAS写入速度(Base on oceanfile tool)" /><published>2023-06-06T00:00:00+08:00</published><updated>2023-06-06T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2023/06/06/calc_NAS_write_speed</id><content type="html" xml:base="http://0.0.0.0:4000/2023/06/06/calc_NAS_write_speed/"># 概述

借助oceanfile（类似mdtest或者vdbench的一个工具），快速观察写不同block size的file（含多层目录），NAS的性能表现如何。

此脚本方便快速获取NAS的读写性能，下班前tmux在被测环境中跑一夜，第二天观察统计结果即可。


# 脚本内容

run_oceanfile_calc_NAS_performance.sh


```
#!/bin/bash

EFILE=/usr/local/bin/oceanfile
target_no=5000000
WRITE_DIR=&quot;/vol/nas02/&quot;
LOG=&quot;/var/log/nas_ocean.log&quot;


function check_arch()
{   
    new_arch=(`echo $arch | tr ',' ' '` )
    total_no=1 
    for var in ${new_arch[@]}
    do  
        # echo $var
        let total_no*=$var
    done 

    if [[ ${total_no} -ne ${target_no} ]]; then
        echo ''
        echo '[ERROR]  The current round amount of data: (${total_no}) is less than expected amount of data: (${target_no})'
        echo ''
        exit 1
    fi
}


if [ $# != 3 ] ; then
    echo &quot;&quot;
    echo &quot;USAGE: $0 parallel size arch&quot;
    echo &quot;  e.g.: $0 20 64 10,10,10,10,100&quot;
    echo &quot;&quot;
    exit 1;
fi

parallel=$1
file_size=$2  # Unit is K
arch=$3

# Check arch numbers
check_arch

for round in {1..22}
do
    while (( $(ps aux | grep -w oceanfile | grep -v grep | wc -l) &gt;= 1 )); do
        sleep 60
    done

    write_dir=${WRITE_DIR}/round_${round}

    if [[ ! -d ${write_dir} ]]; then
        mkdir -p ${write_dir}
    fi

    echo $(date) ROUND ${round} BEGIN  &gt;&gt;$LOG 2&gt;&amp;1
    start_time=`echo $[$(date +%s%N)/1000000]`
    ${EFILE} -d ${write_dir} -p ${parallel} -s ${file_size}k -b ${file_size}k -a ${arch} -i 5 &gt;&gt;$LOG 2&gt;&amp;1 
    end_time=`echo $[$(date +%s%N)/1000000]`

    diff=`expr ${end_time} - ${start_time}`
    time_diff=`echo | awk &quot;{print $diff/1000}&quot;`
    avg_speed=`echo | awk &quot;{print ${target_no}/${time_diff}}&quot;`
   
    # echo ROUND $round &quot;* ${target_no}  cost $time_diff (ms) avg_speed $avg_speed&quot;
    printf &quot;ROUND %-8s  %12d (Files)       Cost %10.2f (s)  Avage: %8.2f\n&quot; $round $target_no $time_diff $avg_speed
    
    echo &gt;&gt;$LOG 2&gt;&amp;1
    echo &quot;ROUND $round  * $target_no (files) cost $time_diff (s)  avg_speed: $avg_speed&quot; &gt;&gt; $LOG 2&gt;&amp;1
    echo $(date) ROUND ${round} FINISH  &gt;&gt;$LOG 2&gt;&amp;1
    echo &gt;&gt;$LOG 2&gt;&amp;1
    echo &gt;&gt;$LOG 2&gt;&amp;1
done
```</content><author><name>Gavin</name></author><category term="ceph" /><category term="shell" /><summary type="html">概述</summary></entry><entry><title type="html">备份Mysql数据库</title><link href="http://0.0.0.0:4000/2023/06/03/backup_mysql_db/" rel="alternate" type="text/html" title="备份Mysql数据库" /><published>2023-06-03T00:00:00+08:00</published><updated>2023-06-03T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2023/06/03/backup_mysql_db</id><content type="html" xml:base="http://0.0.0.0:4000/2023/06/03/backup_mysql_db/"># 概述

Lab 环境中有一套TestLink（测试用例管理平台）和一套 media wiki（存放大家日常工作中写的总结性、经验性文档），他们共用一套MySQL 数据库(不同的db user)。

为了确保数据不丢失，需要每天备份一次mysql，目前的备份策略是全量备份，并同步到一台NAS服务器指定目录。

设置的crontab job，每天凌晨1点执行备份，并sync。


# 实践

## mysql_backup.sh


```
#!/bin/bash
#This script backup the mysql databases and attachments automatically.
 
#variable list
DbName=( 'testlink' 'bugs' 'wikidb' )   # testlink, bugzilla, mediawiki
DbUser=( 'root' 'bugs' 'wikiuser' )
DbPwd=( 'p@ssw0rd' 'bigtera!@#' '111111' )
PicPath=( '/var/www/html/testlink/upload_area/nodes_hierarchy/' '' '/var/www/html/mediawiki/images/' )  # 备份附件等其他目录
BackupPath=/root/mysql_backup/
LogFile=/root/mysql_backup/log_file
 
#check the backup file exists or not
if [ ! -d $BackupPath ]; then
    mkdir $BackupPath
fi

echo &quot;-----------------------------------------&quot;
echo $(date +&quot;%y-%m-%d %H:%M:%S&quot;)
echo $(date +&quot;%y-%m-%d %H:%M:%S&quot;) &gt;&gt; $LogFile
echo &quot;-----------------------------------------&quot;

for ((i=0;i&lt;${#DbName[@]};i++))
do
    NewFile=&quot;$BackupPath&quot;${DbName[$i]}_DB_$(date +%y-%m-%d).tar.gz
    DumpFile=&quot;$BackupPath&quot;${DbName[$i]}_DB_$(date +%y-%m-%d).sql
    OldFile=&quot;$BackupPath&quot;${DbName[$i]}_DB_$(date +%y-%m-%d --date='1 weeks ago').tar.gz

    #create new backup file weekly
    if [ -f $NewFile ]; then
        echo &quot;New backup file have exists!&quot;
    else
        mysqldump -u${DbUser[$i]} -p${DbPwd[$i]} ${DbName[$i]} &gt; $DumpFile
        tar czvf $NewFile $DumpFile ${PicPath[$i]}
        rm -rf $DumpFile
        echo &quot;[$NewFile] backup completely!&quot; &gt;&gt; $LogFile
    fi

    #remove the obsolete file
    if [ -f $OldFile ]; then
        rm -f $OldFile
        echo &quot;delete the old file: [$OldFile]&quot;
    fi
done
```</content><author><name>Gavin</name></author><category term="shell" /><category term="mysql" /><summary type="html">概述</summary></entry></feed>